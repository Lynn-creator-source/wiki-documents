# OV5647

本文档主要介绍camera的开发适配流程，以ov5647为例。

## Camera架构概要

### 常见名词

| 名词                  | 解释                             |
| ------------------- | ------------------------------ |
| ISP                 | 图像信号处理器，用于图像去噪、白平衡、色彩校正等。      |
| Bayer               | 即摄像头传感器，使用Bayer滤色阵列捕获图像。       |
| CSI                 | 摄像头串行接口，用于摄像头与处理器之间的数据传输。      |
| V4L2                | Linux内核的视频捕获和输出框架。             |
| libargus            | NVIDIA提供的高级摄像头控制库。             |
| Camera Core Library | 提供应用程序与内核模式V4L2驱动程序之间的控制和处理功能。 |
| GStreamer           | 开源的多媒体处理框架，用于音视频处理。            |
| Host1x              | NVIDIA Tegra SoC中的主机接口控制器。     |
| Aperture            | 光圈控制，用于调节镜头的光圈大小。              |
| UVC                 | USB视频类，用于USB摄像头的驱动程序。          |
| VI                  | 视频输入模块，用于接收和处理视频数据。            |

### Camera SW 架构

    在Nvidia平台提供了两个Camera驱动架构，分别是 **Camera Core Library Interface** 和 **Direct V4L2 Interface** 。二者主要区别在于前者提供对Jetson平台上ISP的访问和高级图像处理功能，以及导出相关接口给应用空间的libargus使用。libargus是Jeptpack提供了简化的API来访问Jetson平台的相机功能和ISP，如后续使用的nvgstcapture-1.0工具也是基于该库。

    由于后续需要使用Nvdia相关的ISP功能，因此将开发适配Camera Core Library Interface框架。

## OV5647驱动适配过程

### 前置调前

- 获取Camera i2c地址，确认线序，pown\reset引脚

- 获取Camera上电时序，时钟，支持分辨率，帧率，摄像头滤色器阵列（BGGR、GBRG、GRBG、RGGB）

- 确认摄像头连接接口，对应相应的tegra_sinterface，如Jetson orin nx的cam1对应serial_a，cam0对应serial_c

- ov5647驱动源码链接：

**本次开发适配是基于Jetson Orin NX平台，硬件连接接口为cam0。**

### 设备树

- OV5647的DTB采用overlay的方式进行加载，因此在内核源码中创建DTS文件，路径如下：
  
  ```shell
  Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-ov5647.dts`
  ```

- 创建`tegra-camera-platform`设备树节点
  
  ```nand2tetris-hdl
  tegra-capture-vi  {
      num-channels = <1>;
      ports {
          #address-cells = <1>;
          #size-cells = <0>;
          vi_port1: port@1 {
              reg = <0>;
              rbpcv2_ov5647_vi_in1: endpoint {
                  port-index = <2>;
                  bus-width = <2>;
                  remote-endpoint = <&rbpcv2_ov5647_csi_out1>;
              };
          };
      };
  };
  ```

- 在i2c节点下创建`rbpcv2_ov5647_c@36` 设备，并且根据datasheet填写i2c设备地址、mode的时钟、分辨率和帧率等信息
  
  ```nand2tetris-hdl
  rbpcv2_ov5647_c@36 {
      reset-gpios = <&gpio CAM0_RST GPIO_ACTIVE_HIGH>;
      pwdn-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
      compatible = "ovti,ov5647";
      /* I2C device address */
      reg = <0x36>;
      /* V4L2 device node loation */
      devnode = "video0";
      /* Physical dimensions of sensor */
      physical_w = "3.670";
      physical_h = "2.740";
      sensor_model = "ov5647";
      use_sensor_mode_id = "true";
  
      clocks = <&bpmp TEGRA234_CLK_EXTPERIPH2>,
              <&bpmp TEGRA234_CLK_PLLP_OUT0>;
      clock-names = "extperiph2", "pllp_grtba";
      mclk = "extperiph2";
      clock-frequency = <24000000>;
  
      mode0 { /* ov5647_MODE0_1920x1080_30FPS */
          mclk_khz = "25000";
          num_lanes = "2";
          // lane_polarity = "4";
          tegra_sinterface = "serial_c";
          phy_mode = "DPHY";
          discontinuous_clk = "yes";
          dpcm_enable = "false";
          cil_settletime = "0";
          active_w = "1920";
          active_h = "1080";
          mode_type = "bayer";
          pixel_phase = "bggr";
          csi_pixel_bit_depth = "10";
          readout_orientation = "90";
          line_length = "2416";
          inherent_gain = "1";
          mclk_multiplier = "3.6669";
          pix_clk_hz = "81666663";
          gain_factor = "16";
          framerate_factor = "1000000";
          exposure_factor = "1000000";
          min_gain_val = "16";
          max_gain_val = "128";
          step_gain_val = "1";
          default_gain = "16";
          min_hdr_ratio = "1";
          max_hdr_ratio = "1";
          min_framerate = "30000000"; /* 30.0 fps */
          max_framerate = "30000000"; /* 30.0 fps */
          step_framerate = "1";
          default_framerate = "45000000"; /* 30.0 fps */
          min_exp_time = "60"; /* us */
          max_exp_time = "30000"; /* us */
          step_exp_time = "1";
          default_exp_time = "10000"; /* us */
          embedded_metadata_height = "0";
      };
  
      ........................
  
      ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
              reg = <0>;
              rbpcv2_ov5647_out1: endpoint {
                  status = "okay";
                  port-index = <1>;
                  bus-width = <2>;
                  remote-endpoint = <&rbpcv2_ov5647_csi_in1>;
              };
          };
      };
  
  };
  ```

- 端口绑定配置，确保视频流的连接关系。
  
  - 从ov5647摄像头设备生成视频数据流，然后传输给CSI 模块，进行接收、解码、解串和初步处理视频数据等操作，接着传输给VI 模块做进一步处理和格式化视频数据，并将其传输到系统内存或其他处理单元。
  
  - 通过`remote-endpoint`连接三个模块。
    
    ```nand2tetris-hdl
    tegra-capture-vi  {
        num-channels = <1>;
        ports {
            #address-cells = <1>;
            #size-cells = <0>;
            vi_port1: port@1 {
                reg = <0>;
                rbpcv2_ov5647_vi_in1: endpoint {
                    port-index = <2>;
                    bus-width = <2>;
                    remote-endpoint = <&rbpcv2_ov5647_csi_out1>;
                };
            };
        };
    }; 
    
    host1x@13e00000 {
        nvcsi@15a00000 {
            num-channels = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            csi_chan1: channel@1 {
                reg = <0>;
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    csi_chan1_port0: port@0 {
                        reg = <0>;
                        rbpcv2_ov5647_csi_in1: endpoint@2 {
                            port-index = <2>;
                            bus-width = <2>;
                            remote-endpoint = <&rbpcv2_ov5647_out1>;
                        };
                    };
                    csi_chan1_port1: port@1 {
                        reg = <1>;
                        rbpcv2_ov5647_csi_out1: endpoint@3 {
                            remote-endpoint = <&rbpcv2_ov5647_vi_in1>;
                        };
                    };
                };
            };
        };
    };
    ```

- 配置Makefile，`/home/xuys8233/work/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/Makefile` ，添加如下信息：
  
  ```
  dtbo-y += tegra234-p3767-camera-p3768-ov5647.dtbo
  ```

- 编译生成dtbo
  
  ```
  make dtbs
  ```

### 驱动适配

- 添加驱动文件`/home/xuys8233/work/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/ov5647.c`。 该驱动文件可以基于 `nv_ov5693.c` 进行修改。核心主要有以下几点：

- 通过 NVIDIA 提供的 `tegracam_device_register` 函数注册相机驱动，需要填充以下三个结构体：
  
  - tc_dev->sensor_ops，该结构体包含了与 OV5647 传感器相关的各种操作函数，在使用nvdia的libargus的API，会调用以下的函数。
    
    ```c
    static struct tegracam_sensor_ops ov5647_sensor_ops = {
        .power_on = ov5647_power_on,
        .power_off = ov5647_power_off,
        .write_reg = ov5647_write_reg,
        .read_reg = ov5647_read_reg,
        .set_mode = ov5647_set_mode,
        .start_streaming = ov5647_start_streaming,
        .stop_streaming = ov5647_stop_streaming,
        .sensor_init = ov5647_sensor_init,
    };
    
    ```
  
  - tc_dev->v4l2sd_internal_ops，在结构体当中仅实现了open，因此在用户空间使用不了v4l2-ctl相关工具，如需使用，需要添加 .s_stream = ov5647_s_stream 相关的功能函数。
  
  - tc_dev->tcctrl_ops

- 添加头文件`/home/xuys8233/work/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/ov5647_modes_tbls.h`。主要包含了sensor的分辨率、曝光时间等信息的寄存器表。
  
  - 该表会会被tc_dev->sensor_ops结构体注册。
  
  - 接着就是配置每个分辨率所调用的寄存器表，如start_stream。后续set_mode、set_gain等函数会调用该表的寄存器配置，进行写入。（**注：每一个分辨率的顺序需要和设备树中的mode顺序保持一致**）

- 配置Makefile，修改`/home/xuys8233/work/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/Makefile`
  
  ```shell
  obj-m += ov5647.o
  ```

- 编译模块，生成ov5647.ko    
  
  ```shell
  make modules
  ```

### 系统驱动适配

- 启动设备，将编译好的dtbo和ov5647.ko拷贝通过scp拷贝到AIBOX上。

```
cd Linux_for_Tegra/source

scp ./kernel-devicetree/generic-dts/dtbs/tegra234-p3767-camera-p3768-ov5647.dtbo milesight@192.168.60.3:/home/milesight
scp ./kernel-devicetree/generic-dts/dtbs/tegra234-p3767-camera-p3768-ov5647.dtbo milesight@192.168.60.3:/home/milesight
```

- 拷贝ov5647.ko到modules目录下，并执行depmod加载驱动

```
sudo cp ./ov5647.ko  /usr/lib/modules/5.15.148-tegra/updates/drivers/media/i2c/

depmod
```

- 拷贝dtbo到/boot目录下，通过config-by-hardware.py启动dtbo，如下图

- 完成后，重启开发板即可。

## 调试思路

- 确认dtbo是否加载成功
  
  - 执行 `cat /boot/extlinux/extlinux.conf`确认是否加载了dtbo
  
  - 执行`cat /proc/device-tree/tegra-camera-platform/modules/module1/drivernode0/sysfs-device-tree`，确认dtbo是否生效。（extlinux.conf配置上了dtbo，但是不一定有使用上，可能存在dtbo存在错误导致无法生效，该错误不会显示出来，因此要确认该步骤）

- 确认驱动是否加载成功
  
  - 执行`lsmod | grep ov5647`，确认是否有ov5647驱动
  
  - 执行`sudo dmesg | grep ov5647`，确认驱动加载过程中是否存在报错
  
  - 通过`sudo i2cdetect -y -r 9` ,确认设备是否匹配成功

- 确认加载没问题后，运行`nvgstcapture-1.0`去调用sensor
  
  - 确认列出来的分辨率是否和设备树的mode是否是否匹配
  
  - 确认有误其他报错信息，如出现下述nvbuf_utils，需确认是否dmesg是否有报错信息

- 通过`sudo media-ctl -p -d /dev/media0` 确认是否视频流链路是否存在问题

## 参考

[Sensor Software Driver Programming](https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/SD/CameraDevelopment/SensorSoftwareDriverProgramming.html)

[ov5647_driver/ov5647.c at main · mkm684/ov5647_driver](https://github.com/mkm684/ov5647_driver/blob/main/ov5647.c)

数据手册
